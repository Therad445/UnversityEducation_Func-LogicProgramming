Давайте решим поставленные задачи.

1. Построим деревья вызова для запросов:

```prolog
?- предок_потомок(алексей, сергей).

          предок_потомок
              |
         +----+-------+
         |            |
       отец       предок_потомок
                    |
               +----+-------+
               |            |
              сын          отец
                           |
                          сергей
```

```prolog
?- my_member(List, 1).

          my_member
              |
          +---+----+
          |        |
         List       1
```

2. Зададим предикат `ordered(List)`, который успешен, если элементы List расположены в порядке возрастания:

```prolog
ordered([]). % Базовый случай: пустой список считается упорядоченным.
ordered([_]). % Базовый случай: список из одного элемента также считается упорядоченным.

ordered([X,Y|T]) :- % Проверяем первые два элемента и хвост списка.
    X =< Y, % Если первый элемент меньше или равен второму,
    ordered([Y|T]). % рекурсивно проверяем оставшуюся часть списка.

```

3. Зададим предикат `sublist(List1, List2)`, успешный, если List2 является отрезком List1:

```prolog
sublist([], []).
sublist([], [_|_]).
sublist([X|Xs], [X|Ys]) :- sublist(Xs, Ys).
sublist(Xs, [_|Ys]) :- sublist(Xs, Ys).
```

Проверим поведение предиката `sublist` с переменными на других местах:

```prolog
?- sublist(X, [a,b,c]).
X = [];
X = [a];
X = [a, b];
X = [a, b, c];
X = [b];
X = [b, c];
X = [c];
false.

?- sublist([a,b], X).
X = [a, b|_G1190];
X = [_, a, b|_G1190];
X = [_, _, a, b|_G1190];
...
```
